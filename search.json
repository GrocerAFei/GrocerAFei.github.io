[{"title":"回溯法思想及其经典问题的应用","url":"/2025/04/25/hello-world/","content":"回溯法的核心思想基于“试错”——通过尝试分步去解决一个问题，在解决过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解时，它将取消上一步甚至是几步的计算，再通过其他的可能的分步解再次尝试找到问题的答案。\n因此，回溯算法非常适合于解决那些有多个步骤，每一步都有多个选择的问题，在组合问题、排列问题、分割问题等领域表现出色。\n\n代码框架void backtrack(路径, 选择列表) &#123;    if (满足结束条件) &#123;        result.add(路径);        return;    &#125;    for (选择 : 选择列表) &#123;        做选择;        backtrack(路径, 选择列表);        撤销选择;    &#125;&#125;\n\n路径记录（Path）它记录了从根节点到当前节点的路径。用于表示当前的解决方案状态。\n选择列表（Choices）包含了当前节点可以做出的所有选择，通常需要在进入下一层递归前进行更新。\n结束条件（Termination）指明何时将当前路径的解决方案添加到结果集中或者终止递归。\n经典问题\n全排列：给定一个不同的整数集合，返回所有可能的排列。\nN皇后问题：在NxN的棋盘上摆放N个皇后，使得它们不能相互攻击。\n组合总和：找出所有可以使数字和为目标数的组合。\n括号生成：生成所有可能的并且有效的括号组合。\n\n力扣习题","categories":["算法"],"tags":["回溯法"]},{"title":"STL常用容器及使用总结","url":"/2025/04/27/STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","content":"Vector常用成员变量#include &lt;vector&gt;vector&lt;type&gt; v;v.front()\t//返回容器中的第一个数据v.back()\t//返回容器中的最后一个数据v.at(index)\t//返回 v[index] ，会进行边界检查，如果越界会报错，比直接使用 [] 更好一些，常在项目中使用v.size()\t//返回实际数据个数（unsigned类型）v.begin()\t//返回首元素的迭代器（通俗来说就是地址）v.end()\t\t//返回最后一个元素后一个位置的迭代器（地址）v.empty()\t//判断是否为空，为空返回真，反之返回假v.reserve(size)\t//为数组提前分配size的内存大小，主要是为了防止在 push_back 过程中多次的内存拷贝v.assign(beg, end)\t//将另外一个容器[x.begin(), x.end()) 里的内容拷贝到c中v.pop_back()\t//删除最后一个数据v.push_back(element)\t//在尾部加一个数据v.emplace_back(element)\t//在数组中加入一个数据，和 push_back 功能基本一样，在某些情况下比它效率更高，支持传入多个构造参数v.clear()\t//清除容器中的所有元素v.resize(n, v)\t//改变数组大小为n,n个空间数值赋为v，如果没有默认赋值为0v.insert(pos, x)\t//向任意迭代器pos插入一个元素x//例：c.insert(c.begin() + 2, -1)\t将-1插入c[2]的位置v.erase(first, last)\t//删除[first, last)的所有元素\n\nsort函数在C++中， sort 函数是一个标准库算法，用于对数组或容器中的元素进行排序。它定义在  头文件中。\n#include &lt;algorithm&gt;//两种函数原型 first、last是迭代器 分别指向要排序的序列的起始位置和结束位置（不包括结束位置）void sort(first,last);  //默认为升序排序void sort(first,last,cmp);  //cmp是一个可选的比较函数或函数对象，它接受两个参数并返回一个布尔值，指示第一个参数是否应该排在第二个参数之前。// 自定义比较函数bool cmp(int a, int b) &#123;    return a &gt; b; // 如果a大于b，返回true，实现反向排序&#125;\n如果容器中的元素是自定义的类或结构体，你需要重载”&lt;”运算符来定义元素的比较逻辑。下面是一个示例：\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;// 定义一个结构体struct Person &#123;  std::string name;  int age;  // 重载&lt;运算符，用于比较Person对象  bool operator&lt;(const Person&amp; other) const &#123;    return age &lt; other.age; // 按年龄排序  &#125;&#125;;int main() &#123;  std::vector&lt;Person&gt; people;  people.push_back(&#123;&quot;Alice&quot;, 30&#125;);  people.push_back(&#123;&quot;Bob&quot;, 25&#125;);  people.push_back(&#123;&quot;Charlie&quot;, 35&#125;);  // 使用默认比较，因为Person结构体重载了&lt;运算符  std::sort(people.begin(), people.end());  // 打印排序后的vector  for (const auto&amp; person : people) &#123;    std::cout &lt;&lt; person.name &lt;&lt; &quot; (&quot; &lt;&lt; person.age &lt;&lt; &quot;) &quot;;    &#125;    std::cout &lt;&lt; std::endl;    return 0;&#125;\n\n元素访问\n下标法和普通数组一样\n  \n迭代器法类似指针一样的访问\n\nvector&lt;int&gt; vi; //定义一个vi数组vector&lt;int&gt;::iterator it = vi.begin();//声明一个迭代器指向vi的初始位置for(int i = 0; i &lt; 5; i++)  cout &lt;&lt; *(it + i) &lt;&lt; &quot; &quot;;\n\n\nauto法\n\n// 1. 输入vector&lt;int&gt; a(n);for (auto &amp;x: a) &#123;  cin &gt;&gt; x; // 可以进行输入，注意加引用&#125;// 2. 输出vector&lt;int&gt; v;v.push_back(12);v.push_back(241);for(auto val : v) &#123;  cout &lt;&lt; val &lt;&lt; &quot; &quot;; // 12 241&#125;\nStack常用成员变量#include &lt;stack&gt;stack&lt;type&gt; s;s.push(element)\t//元素element入栈，增加元素s.pop()\t\t//移除栈顶元素s.top()\t\t//取得栈顶元素（但不删除）s.empty()\t//检测栈内是否为空，空为真s.size()\t//返回栈内元素的个数\n\nQueueListSetMap","categories":["算法"],"tags":["C/C++","STL"]}]