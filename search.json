[{"title":"STM32学习笔记————1.STM32芯片解读","url":"/2025/07/08/STM32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%941.STM32%E8%8A%AF%E7%89%87%E8%A7%A3%E8%AF%BB/","content":"命名规则STM32\n\nST： 代表STMicroelectronics，这是一家总部位于瑞士的半导体制造公司。\nM： 代表微控制器（MCU）或者包含处理器核心的嵌入式系统。\n32： 代表32位的处理器架构。\n\n通用资源GPIOGPIO:General Purpose Input/Output 通用输入输出GPIO是通用输入输出端口的简称，简单来说就是STM32可控制的引脚，STM32芯片的GPIO引脚与外部设备连接起来，从而实现与外部通讯、控制以及数据采集的功能。主要功能包括：输入（采集）：GPIO 可以配置为输入模式，用于采集外部器件的信息。例如，连接传感器、开关或按钮等外部设备，通过 GPIO 读取这些设备的状态。输出（控制）：GPIO 也可以配置为输出模式，用于控制外部器件的工作。例如，连接LED、继电器、驱动器等外部设备，通过 GPIO 输出电平信号来控制这些设备的工作状态。\nGPIO的八种模式分析\n","categories":["STM32","嵌入式"],"tags":["STM32学习笔记","STM32F407"]},{"title":"STL常用容器及使用总结","url":"/2025/04/27/STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","content":"STL(standard template libaray):标准模板库，其设计思想是泛型编程，即通过模板实现算法的数据结构的高度通用性，以提升开发者的效率。STL包含六大组件：容器(Containers)、迭代器(Iterators)、算法(Algorithms)、函数对象(Function Objects)、适配器(Adapters)和分配器(Allocators)。容器：提供了各种数据结构，如向量、链表、队列、栈、集合、映射等，用于存储和管理数据。迭代器：提供了一种统一的访问容器元素的方式，使得算法可以独立于容器实现。算法：包含了大量常用的算法，如排序、查找、复制、变换等，可以直接应用于各种容器。函数对象：用于封装函数行为的对象，可用于自定义算法的行为。适配器:提供了一种改变容器接口的方式，如栈和队列的适配器。分配器:管理内存的分配和释放，允许用户自定义内存管理策略。\nVector定义和初始化#include &lt;vector&gt;vector&lt;int&gt; vi; //一维初始化vector&lt;int&gt; vi(n);  //定义一个长度为n，初始默认值为0的容器vector&lt;int&gt; vi(n,1); //定义一个长度为n，初始值默认为1的容器//拷贝初始化vector&lt;int&gt; a&#123;5,4,3,2,1&#125;;  //长度为5的容器，内容为5，4，3，2，1vector&lt;int&gt; b(a); //若两容器元素类型相同，将容器a的内容和长度拷贝至容器bvector&lt;int&gt; b=a;  //拷贝初始化的另一种表达式，效果相同//二维初始化  注意区分vector&lt;int&gt; v[6];   //行不可变，列可变v[0].push_back(0);v[1].push_back(1);vector&lt;vector&lt;int&gt;&gt; v;  //行列均可变\n常用成员变量#include &lt;vector&gt;vector&lt;type&gt; v;v.front()\t//返回容器中的第一个数据v.back()\t//返回容器中的最后一个数据v.at(index)\t//返回 v[index] ，会进行边界检查，如果越界会报错，比直接使用 [] 更好一些，常在项目中使用v.size()\t//返回实际数据个数（unsigned类型）v.begin()\t//返回首元素的迭代器（通俗来说就是地址）v.end()\t\t//返回最后一个元素后一个位置的迭代器（地址）v.empty()\t//判断是否为空，为空返回真，反之返回假v.reserve(size)\t//为数组提前分配size的内存大小，主要是为了防止在 push_back 过程中多次的内存拷贝v.assign(beg, end)\t//将另外一个容器[x.begin(), x.end()) 里的内容拷贝到c中v.pop_back()\t//删除最后一个数据v.push_back(element)\t//在尾部加一个数据v.emplace_back(element)\t//在数组中加入一个数据，和 push_back 功能基本一样，在某些情况下比它效率更高，支持传入多个构造参数v.clear()\t//清除容器中的所有元素v.resize(n, v)\t//改变数组大小为n,n个空间数值赋为v，如果没有默认赋值为0v.insert(pos, x)\t//向任意迭代器pos插入一个元素x//例：c.insert(c.begin() + 2, -1)\t将-1插入c[2]的位置v.erase(first, last)\t//删除[first, last)的所有元素\n\nsort函数在C++中， sort 函数是一个标准库算法，用于对数组或容器中的元素进行排序。它定义在  头文件中。\n#include &lt;algorithm&gt;//两种函数原型 first、last是迭代器 分别指向要排序的序列的起始位置和结束位置（不包括结束位置）void sort(first,last);  //默认为升序排序void sort(first,last,cmp);  //cmp是一个可选的比较函数或函数对象，它接受两个参数并返回一个布尔值，指示第一个参数是否应该排在第二个参数之前。// 自定义比较函数bool cmp(int a, int b) &#123;    return a &gt; b; // 如果a大于b，返回true，实现反向排序&#125;\n如果容器中的元素是自定义的类或结构体，你需要重载”&lt;”运算符来定义元素的比较逻辑。下面是一个示例：\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;// 定义一个结构体struct Person &#123;  std::string name;  int age;  // 重载&lt;运算符，用于比较Person对象  bool operator&lt;(const Person&amp; other) const &#123;    return age &lt; other.age; // 按年龄排序  &#125;&#125;;int main() &#123;  std::vector&lt;Person&gt; people;  people.push_back(&#123;&quot;Alice&quot;, 30&#125;);  people.push_back(&#123;&quot;Bob&quot;, 25&#125;);  people.push_back(&#123;&quot;Charlie&quot;, 35&#125;);  // 使用默认比较，因为Person结构体重载了&lt;运算符  std::sort(people.begin(), people.end());  // 打印排序后的vector  for (const auto&amp; person : people) &#123;    std::cout &lt;&lt; person.name &lt;&lt; &quot; (&quot; &lt;&lt; person.age &lt;&lt; &quot;) &quot;;    &#125;    std::cout &lt;&lt; std::endl;    return 0;&#125;\n\n元素访问\n下标法和普通数组一样\n  \n迭代器法类似指针一样的访问\n\nvector&lt;int&gt; vi; //定义一个vi数组vector&lt;int&gt;::iterator it = vi.begin();//声明一个迭代器指向vi的初始位置for(int i = 0; i &lt; 5; i++)  cout &lt;&lt; *(it + i) &lt;&lt; &quot; &quot;;\n\n\nauto法\n\n// 1. 输入vector&lt;int&gt; a(n);for (auto &amp;x: a) &#123;  cin &gt;&gt; x; // 可以进行输入，注意加引用&#125;// 2. 输出vector&lt;int&gt; v;v.push_back(12);v.push_back(241);for(auto val : v) &#123;  cout &lt;&lt; val &lt;&lt; &quot; &quot;; // 12 241&#125;\nStack定义和初始化#include &lt;stack&gt;stack&lt;T, Container&gt; s;//T：存储的元素类型。//Container：底层容器类型，默认为deque&lt;T&gt;//定义一个存储整数的栈：stack&lt;int&gt; myStack;//例如，使用vector作为底层容器：stack&lt;int,vector&lt;int&gt;&gt; s;\n底层容器的选择deque（默认）：deque支持高效的随机访问和两端操作，适合作为stack的底层容器。vector：vector在尾部插入和删除操作上效率很高，但需要注意内存重新分配的问题。list：list在任何位置的插入和删除操作效率都很高，但内存开销较大。\n常用成员变量s.push(element)\t//元素element入栈，增加元素s.pop()\t\t//移除栈顶元素s.top()\t\t//取得栈顶元素（但不删除）s.empty()\t//检测栈内是否为空，空为真s.size()\t//返回栈内元素的个数\nMap定义和初始化map以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。Map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。\n","categories":["算法"],"tags":["C/C++","STL"]},{"title":"回溯法思想及其经典问题的应用","url":"/2025/04/25/%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%80%9D%E6%83%B3%E5%8F%8A%E5%85%B6%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E7%9A%84%E5%BA%94%E7%94%A8/","content":"回溯法的核心思想基于“试错”——通过尝试分步去解决一个问题，在解决过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解时，它将取消上一步甚至是几步的计算，再通过其他的可能的分步解再次尝试找到问题的答案。\n因此，回溯算法非常适合于解决那些有多个步骤，每一步都有多个选择的问题，在组合问题、排列问题、分割问题等领域表现出色。\n\n代码框架void backtrack(路径, 选择列表) &#123;    if (满足结束条件) &#123;        result.add(路径);        return;    &#125;    for (选择 : 选择列表) &#123;        做选择;        backtrack(路径, 选择列表);        撤销选择;    &#125;&#125;\n\n路径记录（Path）它记录了从根节点到当前节点的路径。用于表示当前的解决方案状态。\n选择列表（Choices）包含了当前节点可以做出的所有选择，通常需要在进入下一层递归前进行更新。\n结束条件（Termination）指明何时将当前路径的解决方案添加到结果集中或者终止递归。\n经典问题\n全排列：给定一个不同的整数集合，返回所有可能的排列。\nN皇后问题：在NxN的棋盘上摆放N个皇后，使得它们不能相互攻击。\n组合总和：找出所有可以使数字和为目标数的组合。\n括号生成：生成所有可能的并且有效的括号组合。\n\n力扣习题","categories":["算法"],"tags":["回溯法"]}]