[{"title":"回溯法思想及其经典问题的应用","url":"/2025/04/25/%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%80%9D%E6%83%B3%E5%8F%8A%E5%85%B6%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E7%9A%84%E5%BA%94%E7%94%A8/","content":"回溯法的核心思想基于“试错”——通过尝试分步去解决一个问题，在解决过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解时，它将取消上一步甚至是几步的计算，再通过其他的可能的分步解再次尝试找到问题的答案。\n因此，回溯算法非常适合于解决那些有多个步骤，每一步都有多个选择的问题，在组合问题、排列问题、分割问题等领域表现出色。\n\n代码框架void backtrack(路径, 选择列表) &#123;    if (满足结束条件) &#123;        result.add(路径);        return;    &#125;    for (选择 : 选择列表) &#123;        做选择;        backtrack(路径, 选择列表);        撤销选择;    &#125;&#125;\n\n路径记录（Path）它记录了从根节点到当前节点的路径。用于表示当前的解决方案状态。\n选择列表（Choices）包含了当前节点可以做出的所有选择，通常需要在进入下一层递归前进行更新。\n结束条件（Termination）指明何时将当前路径的解决方案添加到结果集中或者终止递归。\n经典问题\n全排列：给定一个不同的整数集合，返回所有可能的排列。\nN皇后问题：在NxN的棋盘上摆放N个皇后，使得它们不能相互攻击。\n组合总和：找出所有可以使数字和为目标数的组合。\n括号生成：生成所有可能的并且有效的括号组合。\n\n力扣习题","categories":["算法"],"tags":["回溯法"]},{"title":"STL常用容器及使用总结","url":"/2025/04/27/STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","content":"STL(standard template libaray):标准模板库，其设计思想是泛型编程，即通过模板实现算法的数据结构的高度通用性，以提升开发者的效率。STL包含六大组件：容器(Containers)、迭代器(Iterators)、算法(Algorithms)、函数对象(Function Objects)、适配器(Adapters)和分配器(Allocators)。容器：提供了各种数据结构，如向量、链表、队列、栈、集合、映射等，用于存储和管理数据。迭代器：提供了一种统一的访问容器元素的方式，使得算法可以独立于容器实现。算法：包含了大量常用的算法，如排序、查找、复制、变换等，可以直接应用于各种容器。函数对象：用于封装函数行为的对象，可用于自定义算法的行为。适配器:提供了一种改变容器接口的方式，如栈和队列的适配器。分配器:管理内存的分配和释放，允许用户自定义内存管理策略。\nVector定义和初始化#include &lt;vector&gt;vector&lt;int&gt; vi; //一维初始化vector&lt;int&gt; vi(n);  //定义一个长度为n，初始默认值为0的容器vector&lt;int&gt; vi(n,1); //定义一个长度为n，初始值默认为1的容器//拷贝初始化vector&lt;int&gt; a&#123;5,4,3,2,1&#125;;  //长度为5的容器，内容为5，4，3，2，1vector&lt;int&gt; b(a); //若两容器元素类型相同，将容器a的内容和长度拷贝至容器bvector&lt;int&gt; b=a;  //拷贝初始化的另一种表达式，效果相同//二维初始化  注意区分vector&lt;int&gt; v[6];   //行不可变，列可变v[0].push_back(0);v[1].push_back(1);vector&lt;vector&lt;int&gt;&gt; v;  //行列均可变\n常用成员变量#include &lt;vector&gt;vector&lt;type&gt; v;v.front()\t//返回容器中的第一个数据v.back()\t//返回容器中的最后一个数据v.at(index)\t//返回 v[index] ，会进行边界检查，如果越界会报错，比直接使用 [] 更好一些，常在项目中使用v.size()\t//返回实际数据个数（unsigned类型）v.begin()\t//返回首元素的迭代器（通俗来说就是地址）v.end()\t\t//返回最后一个元素后一个位置的迭代器（地址）v.empty()\t//判断是否为空，为空返回真，反之返回假v.reserve(size)\t//为数组提前分配size的内存大小，主要是为了防止在 push_back 过程中多次的内存拷贝v.assign(beg, end)\t//将另外一个容器[x.begin(), x.end()) 里的内容拷贝到c中v.pop_back()\t//删除最后一个数据v.push_back(element)\t//在尾部加一个数据v.emplace_back(element)\t//在数组中加入一个数据，和 push_back 功能基本一样，在某些情况下比它效率更高，支持传入多个构造参数v.clear()\t//清除容器中的所有元素v.resize(n, v)\t//改变数组大小为n,n个空间数值赋为v，如果没有默认赋值为0v.insert(pos, x)\t//向任意迭代器pos插入一个元素x//例：c.insert(c.begin() + 2, -1)\t将-1插入c[2]的位置v.erase(first, last)\t//删除[first, last)的所有元素\n\nsort函数在C++中， sort 函数是一个标准库算法，用于对数组或容器中的元素进行排序。它定义在  头文件中。\n#include &lt;algorithm&gt;//两种函数原型 first、last是迭代器 分别指向要排序的序列的起始位置和结束位置（不包括结束位置）void sort(first,last);  //默认为升序排序void sort(first,last,cmp);  //cmp是一个可选的比较函数或函数对象，它接受两个参数并返回一个布尔值，指示第一个参数是否应该排在第二个参数之前。// 自定义比较函数bool cmp(int a, int b) &#123;    return a &gt; b; // 如果a大于b，返回true，实现反向排序&#125;\n如果容器中的元素是自定义的类或结构体，你需要重载”&lt;”运算符来定义元素的比较逻辑。下面是一个示例：\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;// 定义一个结构体struct Person &#123;  std::string name;  int age;  // 重载&lt;运算符，用于比较Person对象  bool operator&lt;(const Person&amp; other) const &#123;    return age &lt; other.age; // 按年龄排序  &#125;&#125;;int main() &#123;  std::vector&lt;Person&gt; people;  people.push_back(&#123;&quot;Alice&quot;, 30&#125;);  people.push_back(&#123;&quot;Bob&quot;, 25&#125;);  people.push_back(&#123;&quot;Charlie&quot;, 35&#125;);  // 使用默认比较，因为Person结构体重载了&lt;运算符  std::sort(people.begin(), people.end());  // 打印排序后的vector  for (const auto&amp; person : people) &#123;    std::cout &lt;&lt; person.name &lt;&lt; &quot; (&quot; &lt;&lt; person.age &lt;&lt; &quot;) &quot;;    &#125;    std::cout &lt;&lt; std::endl;    return 0;&#125;\n\n元素访问\n下标法和普通数组一样\n  \n迭代器法类似指针一样的访问\n\nvector&lt;int&gt; vi; //定义一个vi数组vector&lt;int&gt;::iterator it = vi.begin();//声明一个迭代器指向vi的初始位置for(int i = 0; i &lt; 5; i++)  cout &lt;&lt; *(it + i) &lt;&lt; &quot; &quot;;\n\n\nauto法\n\n// 1. 输入vector&lt;int&gt; a(n);for (auto &amp;x: a) &#123;  cin &gt;&gt; x; // 可以进行输入，注意加引用&#125;// 2. 输出vector&lt;int&gt; v;v.push_back(12);v.push_back(241);for(auto val : v) &#123;  cout &lt;&lt; val &lt;&lt; &quot; &quot;; // 12 241&#125;\nStack定义和初始化#include &lt;stack&gt;stack&lt;T, Container&gt; s;//T：存储的元素类型。//Container：底层容器类型，默认为deque&lt;T&gt;//定义一个存储整数的栈：stack&lt;int&gt; myStack;//例如，使用vector作为底层容器：stack&lt;int,vector&lt;int&gt;&gt; s;\n底层容器的选择deque（默认）：deque支持高效的随机访问和两端操作，适合作为stack的底层容器。vector：vector在尾部插入和删除操作上效率很高，但需要注意内存重新分配的问题。list：list在任何位置的插入和删除操作效率都很高，但内存开销较大。\n常用成员变量s.push(element)\t//元素element入栈，增加元素s.pop()\t\t//移除栈顶元素s.top()\t\t//取得栈顶元素（但不删除）s.empty()\t//检测栈内是否为空，空为真s.size()\t//返回栈内元素的个数\nMap定义和初始化map以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。Map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。\n","categories":["算法"],"tags":["C/C++","STL"]},{"title":"STM32学习笔记——1.STM32芯片解读","url":"/2025/07/08/STM32_1/","content":"命名规则STM32\n\nST： 代表STMicroelectronics，这是一家总部位于瑞士的半导体制造公司。\nM： 代表微控制器（MCU）或者包含处理器核心的嵌入式系统。\n32： 代表32位的处理器架构。\n\n通用资源GPIOGPIO:General Purpose Input/Output 通用输入输出GPIO是通用输入输出端口的简称，简单来说就是STM32可控制的引脚，STM32芯片的GPIO引脚与外部设备连接起来，从而实现与外部通讯、控制以及数据采集的功能。主要功能包括：输入（采集）：GPIO 可以配置为输入模式，用于采集外部器件的信息。例如，连接传感器、开关或按钮等外部设备，通过 GPIO 读取这些设备的状态。输出（控制）：GPIO 也可以配置为输出模式，用于控制外部器件的工作。例如，连接LED、继电器、驱动器等外部设备，通过 GPIO 输出电平信号来控制这些设备的工作状态。\nGPIO的八种模式分析输入浮空（Floating Input）：特点： 输入用，完全浮空，状态不定。应用： 适用于需要读取外部信号的场景，但外部信号状态不确定。\n输入上拉（Input Pull-Up）：特点： 输入用，使用内部上拉电阻，初始状态是高电平。应用： 适用于外部信号默认为高电平的情况，如按钮按下时会拉低信号。\n输入下拉（Input Pull-Down）：特点： 输入用，使用内部下拉电阻，初始状态是低电平。应用： 适用于外部信号默认为低电平的情况，如按钮按下时会拉高信号。\n模拟功能（Analog Mode）：特点： 用于连接模拟外设，如ADC（模数转换器）、DAC（数模转换器）等。应用： 适用于需要进行模拟信号处理的场景。\n开漏输出（Open-Drain Output）：特点： 用于实现开漏输出，常用于构建总线，如I2C。应用： 适用于需要多个输出端口共享同一信号线的场景，例如I2C的SDA、SCL线。\n推挽输出（Push-Pull Output）：特点： 驱动能力强，支持通用输出，可提供较大电流。应用： 适用于需要输出到外部设备，需要较大驱动能力的场景。\n开漏式复用功能（Open-Drain Alternate Function）：特点： 用于实现开漏输出，并复用了片上外设功能。应用： 适用于需要实现外设功能，同时共享信号线的场景，例如硬件I2C的SDA、SCL线。\n推挽式复用功能（Push-Pull Alternate Function）：特点： 用于实现推挽输出，并复用了片上外设功能。应用： 适用于需要实现外设功能，同时需要提供较大驱动能力的场景，例如SPI的SCK、MISO、MOSI线。\nSTM32F407实现小灯闪烁原理解析项目结构解析\nDrivers 文件夹: 用于存放各种底层驱动代码，包括芯片厂家提供的驱动代码、ARM 提供的驱动代码、以及我们自己编写的底层驱动代码等三部分\n\n\nBSP 文件夹: 存放我们自己编写的各种底层驱动代码(（原HARDWARE文件夹下的代码）)，如LED、KEY、BEEP、DHT11、DS18b20、ESP8266等。\nCMSIS 文件夹: 包含 ARM 提供基于 CMSIS 标准的底层代码，简单的说，包含我们新建工程需要的启动文件（.s 文件）和相关头文件（ARM 提供和 ST 独有两部分）等。\nSYSTEM 文件夹: 存放我们自己编写的系统、延时、串口相关的代码，包括sys、delay和usart三个子文件夹，分别提供时钟配置，延时和串口驱动等关键代码,方便项目使用。\nSTM32F4xx_HAL_Driver 文件夹: ST提供的F4 HAL库驱动代码。Inc 包含 HAL 库驱动的各种头文件。Src 包含 HAL 库驱动的各种源码文件。\n\n\nMiddlewares 文件夹: 用于存放各种中间层&#x2F;组件&#x2F;Lib 代码，包括我们自己写的或者第三方提供的，如 USMART、MALLOC、TEXT、PICTURE、FATFS、OS、GUI、USB 等\nOutput 文件夹: 用于存放各种编译中间文件及输出文件(原OBJ文件夹)\nProject 文件夹: 用于存放工程文件,该文件夹下面只包含一个 MDK-ARM 的文件夹，用于存放 MDK 版本工程文件其中：atk_f407.uvprojx，就是 MDK5 的工程文件，DebugConfig 用于存放仿真调试配置信息，由 MDK 自动生成，我们无视他即可。注意：.uvprojx 的命名方式我们统一使用 atk_xxx 的命名方式，如 F103，我们就命名为：atk_f103.uvprojx（注意，是在使用 MDK 新建工程的时候，确定命名的）。\nUser 文件夹: 用于存放用户编写的代码（如果有分散加载，我们也把分散加载文件放这个文件夹下）。其中：main.c: 主要包含了 main 函数。APP 文件夹: 用于存放自己编写的应用代码（绝大部分基础例程代码并不多，只用 main.c实现就够了，并不用 APP 文件夹），因为视频播放代码比较多，所以放在 APP 文件夹里面（videoplayer.c）。 该文件夹是可以删除的，并不一定要保留，只有需要的时候，才留下。SCRIPT 文件夹: 用于存放我们编写分散加载文件，仅 F750&#x2F;H750 等开发板需要这个文件夹，其他开发板用不到分散加载的，都可以删了这个文件夹。\n\n代码解析main.c\nint main(void)&#123;    HAL_Init();                                 /* 初始化HAL库 */    sys_stm32_clock_init(336, 8, 2, 7);         /* 设置时钟,168Mhz */    delay_init(168);                            /* 延时初始化 */    led_init();                                 /* 初始化LED */    while(1)    &#123;        LED0(0);                                /* LED0 亮 */        LED1(1);                                /* LED1 灭 */        delay_ms(500);        LED0(1);                                /* LED0 灭 */        LED1(0);                                /* LED1 亮 */        delay_ms(500);    &#125;&#125;\nled.c\n/** * @brief       初始化LED相关IO口, 并使能时钟 * @param       无 * @retval      无 */void led_init(void)&#123;    GPIO_InitTypeDef gpio_init_struct;        LED0_GPIO_CLK_ENABLE();                                 /* LED0时钟使能 */    LED1_GPIO_CLK_ENABLE();                                 /* LED1时钟使能 */    gpio_init_struct.Pin = LED0_GPIO_PIN;                   /* LED0引脚 */    gpio_init_struct.Mode = GPIO_MODE_OUTPUT_PP;            /* 推挽输出 */    gpio_init_struct.Pull = GPIO_PULLUP;                    /* 上拉 */    gpio_init_struct.Speed = GPIO_SPEED_FREQ_HIGH;          /* 高速 */    HAL_GPIO_Init(LED0_GPIO_PORT, &amp;gpio_init_struct);       /* 初始化LED0引脚 */    gpio_init_struct.Pin = LED1_GPIO_PIN;                   /* LED1引脚 */    HAL_GPIO_Init(LED1_GPIO_PORT, &amp;gpio_init_struct);       /* 初始化LED1引脚 */        LED0(1);                                                /* 关闭 LED0 */    LED1(1);                                                /* 关闭 LED1 */&#125;\nled.h\n#ifndef __LED_H#define __LED_H#include &quot;./SYSTEM/sys/sys.h&quot;/******************************************************************************************//* 引脚 定义 */#define LED0_GPIO_PORT                  GPIOF#define LED0_GPIO_PIN                   GPIO_PIN_9#define LED0_GPIO_CLK_ENABLE()          do&#123; __HAL_RCC_GPIOF_CLK_ENABLE(); &#125;while(0)             /* PF口时钟使能 */#define LED1_GPIO_PORT                  GPIOF#define LED1_GPIO_PIN                   GPIO_PIN_10#define LED1_GPIO_CLK_ENABLE()          do&#123; __HAL_RCC_GPIOF_CLK_ENABLE(); &#125;while(0)             /* PF口时钟使能 *//******************************************************************************************//* LED端口定义 */#define LED0(x)   do&#123; x ? \\                      HAL_GPIO_WritePin(LED0_GPIO_PORT, LED0_GPIO_PIN, GPIO_PIN_SET) : \\                      HAL_GPIO_WritePin(LED0_GPIO_PORT, LED0_GPIO_PIN, GPIO_PIN_RESET); \\                  &#125;while(0)       /* LED0 = RED */#define LED1(x)   do&#123; x ? \\                      HAL_GPIO_WritePin(LED1_GPIO_PORT, LED1_GPIO_PIN, GPIO_PIN_SET) : \\                      HAL_GPIO_WritePin(LED1_GPIO_PORT, LED1_GPIO_PIN, GPIO_PIN_RESET); \\                  &#125;while(0)       /* LED1 = GREEN *//* LED取反定义 */#define LED0_TOGGLE()    do&#123; HAL_GPIO_TogglePin(LED0_GPIO_PORT, LED0_GPIO_PIN); &#125;while(0)       /* LED0 = !LED0 */#define LED1_TOGGLE()    do&#123; HAL_GPIO_TogglePin(LED1_GPIO_PORT, LED1_GPIO_PIN); &#125;while(0)       /* LED1 = !LED1 *//******************************************************************************************//* 外部接口函数*/void led_init(void);                                                                            /* 初始化 */#endif\n\n\n\n","categories":["STM32","嵌入式"],"tags":["STM32学习笔记","STM32F407"]}]